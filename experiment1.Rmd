---
output: 
  html_document:
    keep_md: true
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
source("experiment.R")

H = rbind(c(1, 1), 
          c(1, 1), 
          c(1, 0), 
          c(1, 0), 
          c(0, 1), 
          c(0, 1))

set.seed(0)
R = nrow(H)
d = c(10, 10)

```

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\boldU}{\mathbf{U}}
\newcommand{\boldW}{\mathbf{W}}
\newcommand{\boldV}{\mathbf{V}}
\newcommand{\boldX}{\mathbf{X}}
\newcommand{\boldQ}{\mathbf{Q}}
\newcommand{\boldI}{\mathbf{I}}
\newcommand{\boldbeta}{\boldsymbol{\beta}}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

# MLFS method

Suppose we have $N$ data points, each having a label $y_i \in \{1, ..., C\}$ and information from various views $\boldX^{(m)}, m \in \{1, ..., M\}$. 

For each view $m$, there are view-specific latent matrices $\boldU^{(m)} \in \R^{N \times d_m}$ which are generated by a *shared* latent representation $\boldV \in \R^{N \times R}$ and view-specific sparse weight matrices $\boldW^{(m)} \in \R^{R \times d_m}$. Each row $\boldU_i^{(m)}$ is generated as follows

\[
\boldU_i^{(m)} \sim \N(\boldV_i \boldW^{(m)}, \frac{1}{\gamma_m} \boldI)
\]

Our data $\boldX_{ij}^{(m)}$ is then generated

- for gaussian views, $\boldX_{ij}^{(m)} = \boldU_{ij}^{(m)}$
- for ordinal views, $\boldX_{ij}^{(m)} = l$ if and only if $g_{l-1}^m < \boldU_{ij}^{(m)} < g_l^m$ for some cutpoints $g_0^m < ... < g_{L_m}^m$

And the labels $y_i$ are generated $y_i = \argmax_c{z_{ic}}$, where $z_{ic} \sim \N(\boldV_i \boldbeta_c, 1)$ for classes $c$ and $\boldbeta_c \in \R^R$. 

This is illustrated in the following schema (non-zero elements of $\boldW$ are shaded). 

![](figures/schema1.png)

# Testing MLFS method on simulated data

Generate two views, both with 10 features. Altogether 200 data points (100 for training, 100 for testing), number of classes $C=2$. 

We will consider three scenarios 

- Two Gaussian views
- One gaussian, one ordinal (with 3 levels)
- Both ordinal views (both with 3 levels)

The latent data was generated as follows


That is, data was generated as follows:

* $\boldV_i \sim \N(0, \boldI)$ with dimensionality $R=6$
* sparsity in $\boldW$ was introduced as shown in the figure, nonzero elements of $\boldW^{(m)}$ were drawn from $N(0, 1)$


Performance ("prediction accuracy") reported as the proportion of correct classifications. 

### Sanity check

Perfect scenario (data generated exactly according to the model). 

```{r, echo=FALSE}
# res = three_experiments(experiment0, H, d, R)
load("temp_res0.RData")
df.m = res %>%
  melt(measure.vars = c("train", "test")) 

ggplot(df.m, aes(variable, value, col=variable)) + 
  geom_boxplot() + facet_wrap(~ type) + 
  theme_bw() + ylim(0, 1) + 
  ylab("Prediction accuracy") + xlab("") + 
  scale_color_brewer(palette="Set1")

```

Conclusion:

- I guess, there is no evident bug
- learning from ordinal features is less efficient than from Gaussian ones (expected, I guess)

### How fast does variational Bayes converge?

Explore the lower bound (ELBO) over iterations. 

Also, the authors have noted that the original likelihood remains unchanged for rotations Q,  
\[
\boldU_i^{(m)} \sim \N(\boldV_i \boldW^{(m)}, \gamma^{-1}I) = \N(\boldV_i \boldQ^{-1} \boldQ \boldW^{(m)}, \gamma^{-1}I)
\]
and they have suggested to introduce a rotation Q to the variational family, and optimise w.r.t. Q. Lets explore the effect of this (do it with and without rotation).  

```{r, echo=FALSE}
# type = c("gaussian", "gaussian")
# res1 = experiment_lowerbound(H, d, type)
# type = c("gaussian", "ordinal")
# res2 = experiment_lowerbound(H, d, type)
# type = c("ordinal", "ordinal")
# res3 = experiment_lowerbound(H, d, type)
# res = data.frame(rbind(res1, res2, res3), type = rep(c("gaussian + gaussian", "gaussian + ordinal", "ordinal + ordinal"), each=nrow(res1)))

load("temp_lowerbound.RData")
ggplot(res, aes(iterations, lowerbound, col=rotate)) + 
  geom_line() + facet_wrap(~type) + theme_bw() + 
  scale_color_brewer(palette="Set1")
```

Conclusions: 

1. It seems that about 20 iterations is already enough in these cases, and that convergence (to a local maximum?) is fast. 
2. Rotation is beneficial. 
    - without optimising w.r.t Q, we reach some local extremum and cannot escape it the lower bound is clearly not maximised (cannot escape the local maximum?)
    - it also helps to introduce sparsity to W

### What if we increase the amount of noise

Lets increase the noise in generating $\boldU$, i.e. explore behaviour w.r.t. $\gamma$ in equation $\boldU_i^{(m)} \sim \N(\boldV_i \boldW^{(m)}, \frac{1}{\gamma_m} \boldI)$. 

```{r}
# gammas = c(0.01, 1, 100)
# type = c("gaussian", "gaussian")
# res1 = experiment_gamma(gammas, H, d, type, R)
# type = c("gaussian", "ordinal")
# res2 = experiment_gamma(gammas, H, d, type, R)
# type = c("ordinal", "ordinal")
# res3 = experiment_gamma(gammas, H, d, type, R)
# df = data.frame(rbind(res1, res2, res3), type = rep(c("gaussian + gaussian", "gaussian + ordinal", "ordinal + ordinal"), each=nrow(res1)))

load("temp_gamma.RData")

df.m = df %>%
  melt(measure.vars = c("train", "test")) 

ggplot(df.m, aes(factor(1/gamma), value, col=variable)) + 
  geom_boxplot() + facet_wrap(~ type) + 
  theme_bw() + ylim(0, 1) + 
  xlab("1 / gamma") + ylab("Prediction accuracy") + 
  scale_color_brewer(palette="Set1")
```

```{r}
### Changing the number of views/features?

# First, change the number of features in both of the views (but use still two views).

# d_values = list(c(5, 5), c(10, 10), c(100, 100))
# df = data.frame()
# for(i in 1:length(d_values)){
#   temp = three_experiments(experiment0, H, d_values[[i]], R)
#   df = rbind(df, data.frame(temp, d = d_values[[i]][1]))
# }
# save(df, file="temp_nfeatures.RData")
# load("temp_nfeatures.RData")
# df.m = df %>%
#   melt(measure.vars = c("train", "test")) 
# 
# ggplot(df.m, aes(factor(d), value, col=variable)) + 
#   geom_boxplot() + facet_wrap(~ type) + 
#   theme_bw() + ylim(0, 1) + 
#   xlab("Number of features") + ylab("Prediction accuracy") + 
#   scale_color_brewer(palette="Set1")
```



```{r}
# Now keep the number of features equal to 10, but vary the number of views in $\{2, 3, 4\}$ with a more complex structure in W. 

# H = rbind(c(1, 1, 1, 1), 
#           c(1, 1, 0, 0), 
#           c(1, 0, 1, 0), 
#           c(1, 0, 0, 1), 
#           c(0, 1, 1, 0), 
#           c(0, 1, 0, 1))
# 
# df = data.frame()
# n_views = c(2, 3, 4)
# for(i in 1:length(n_views)){
#   temp = three_experiments(experiment0, H, rep(10, n_views[i]), R, n_views = n_views[i])
#   df = rbind(df, data.frame(temp, n_views = n_views[i]))
# }
# save(df, file="temp_nviews.RData")
# 
# load("temp_nviews.RData")
# df.m = df %>%
#   melt(measure.vars = c("train", "test")) 
# 
# ggplot(df.m, aes(factor(n_views), value, col=variable)) + 
#   geom_boxplot() + facet_wrap(~ type) + 
#   theme_bw() + ylim(0, 1) + 
#   xlab("Number of views") + ylab("Prediction accuracy") + 
#   scale_color_brewer(palette="Set1")
```


### Can the model (ARD prior) handle large number of irrelevant features?

Each view has (10 + irrelevant) features now

```{r, echo=FALSE}
# n_irrelevant_features = c(0, 10, 100, 1000, 10000)
# type = c("gaussian", "gaussian")
# res1 = experiment1(n_irrelevant_features, H, d, type, n_rep = 5)
# type = c("gaussian", "ordinal")
# res2 = experiment1(n_irrelevant_features, H, d, type, n_rep = 5)
# type = c("ordinal", "ordinal")
# res3 = experiment1(n_irrelevant_features, H, d, type, n_rep = 5)
# res = data.frame(rbind(res1, res2, res3), type = rep(c("gaussian + gaussian", "gaussian + ordinal", "ordinal + ordinal"), each=nrow(res1)))
# save(res, file="temp_res1.RData")

load("temp_res1.RData")
df.m = res %>%
  melt(measure.vars = c("train", "test")) 

ggplot(df.m, aes(factor(n_irrelevant_features), value, col=variable)) + 
  geom_boxplot() + facet_wrap(~ type) + 
  theme_bw() + ylim(0, 1) + 
  xlab("Number of irrelevant features") + ylab("Prediction accuracy") + 
  scale_color_brewer(palette="Set1")
```

### What if the dimensionality of latent space is misspecified?

In the generated data, the underlying latent space was 6-dimensional. When fitting the model, lets consider misspecified values $\{2, 4 < 6 < 10, 20\}$. 

```{r, echo=FALSE}
# R_values = c(2, 4, 10, 20)
# type = c("gaussian", "gaussian")
# res1 = experiment2(R_values, H, d, type, n_rep = 5)
# type = c("gaussian", "ordinal")
# res2 = experiment2(R_values, H, d, type, n_rep = 5)
# type = c("ordinal", "ordinal")
# res3 = experiment2(R_values, H, d, type, n_rep = 5)
# res = data.frame(rbind(res1, res2, res3), type = rep(c("gaussian + gaussian", "gaussian + ordinal", "ordinal + ordinal"), each=nrow(res1)))
# save(res, file="temp_res2.RData")
load("temp_res2.RData")
df.m = res %>%
  melt(measure.vars = c("train", "test")) 

ggplot(df.m, aes(factor(latent_dim), value, col=variable)) + 
  geom_boxplot() + facet_wrap(~ type) + 
  theme_bw() + ylim(0, 1) + 
  xlab("Latent space dimensionality") + ylab("Prediction accuracy") + 
  scale_color_brewer(palette="Set1")

```

When this dimensionality is underestimated, it is expected that we may lose in performance (cannot capture so much information). When it is overestimated, it seems to do just fine (reassuring, so in practice "pick R large enough" should do the job). 

### What if there are multiple correlated features

To generate a scenario where there are multiple correlated features, for example

1. One way would be to generate $\boldU$ from $\boldV$ and $\boldW$ as usual, and then modify $\boldU$ by taking its columns and adding new correlated ones
2. Another way would be to create correlated columns in $\boldW$ (i.e. deviate from the assumption that the elements within the row of $\boldW$ are uncorrelated)

Lets start with approach 2. Having constructed original $\boldW^{(m)}$, add $\{1, 5, 10\}$ correlated copies of its columns (correlation with original feature around 0.8). 

```{r}
# n_added = c(1, 5, 10)
# type = c("gaussian", "gaussian")
# res1 = experiment_correlated_features(n_added, H, d, type, R)
# type = c("gaussian", "ordinal")
# res2 = experiment_correlated_features(n_added, H, d, type, R)
# type = c("ordinal", "ordinal")
# res3 = experiment_correlated_features(n_added, H, d, type, R)
# df = data.frame(rbind(res1, res2, res3), 
#                  type = rep(c("gaussian + gaussian", "gaussian + ordinal", "ordinal + ordinal"), each=nrow(res1)))
# save(df, file="temp_correlatedfeatures.RData")

load("temp_correlatedfeatures.RData")
df.m = df %>%
  melt(measure.vars = c("train", "test")) 
ggplot(df.m, aes(factor(n_added), value, col=variable)) + 
  geom_boxplot() + facet_wrap(~ type) + 
  theme_bw() + ylim(0, 1) + 
  xlab("Number of correlated copies of features") + ylab("Prediction accuracy") + 
  scale_color_brewer(palette="Set1")

```

Everything seems OK. When trying out the other approach, similar behaviour was seen. 

Minor comment: Sometimes got an error $\boldQ \boldQ^T$ being not invertible. In such cases I proceeded without optimising w.r.t. rotations any more. 

### What if the Gaussianity assumption is violated

In $\boldU_i^{(m)} \sim \N(\boldV_i \boldW^{(m)}, \frac{1}{\gamma_m} \boldI)$, we can replace the Gaussian distribution with Student t distribution (df=1) with heavier tails. Note that if $\gamma$ is small, the effect of this is also small. In these experiments $\gamma=1$.  

In principle, we could also ask a similar question about Gaussianity in $\boldV$ or $\boldW$, but currently skip this. 

```{r}
# df2 = three_experiments(experiment_gaussianity, H, d, R)
# df2$noise = "t distribution"
# load("temp_gamma.RData")
# 
# df.m =  df %>%
#   filter(gamma == 1) %>%
#   select(-gamma) %>%
#   mutate(noise = "Gaussian") %>%
#   rbind(df2) %>%
#   melt(measure.vars = c("train", "test")) 

load("temp_t_distribution.RData")
ggplot(df.m, aes(noise, value, col=variable)) + 
  geom_boxplot() + facet_wrap(~ type) + 
  theme_bw() + ylim(0, 1) + 
  xlab("") + ylab("Prediction accuracy") + 
  scale_color_brewer(palette="Set1")

```

Quite a large drop in performance. 
